---
title: "Recombination Probabilities"
author:
- Douglas A. Campbell
- Natasha Ryan
date: "`r format(Sys.Date())`"
output:
  html_document:
    df_print: paged
    code_folding: hide
    keep_md: yes
    fig_caption: yes
    toc: TRUE
    toc_float: TRUE   
csl: plos-one.csl
editor_options: 
  chunk_output_type: inline
---



```{r load libraries}

library(tidyverse)
library(readxl)
library(stringr)
library(broom)
library(minpack.lm)
#library(OneR)
library(changepoint)
library(chngpt)
library(broom)
library(Rwave)
library(WaveletComp)

```

# Set Project Variables
```{r set project variables}
Project <- "LOW"
DataIn <- file.path("..","Data", "CleanData")
CalibData <- file.path("..","Data", "CalibData")
FileID <- "SolFitsTrim2"

```


```{r start variables}
PSIIo <- 1000 #PSII)
sigmaPSII <- 250e-20 #m2 photon-1
FlashletEx <- 30000 #umol photons m-2 s-1
Flashlet_s <- 1.2e-6
FlashTrain <- 100
Dark_s <- 2e-6
Photons_umol <- 6.33E17

SNL <- 0.005
Recomb <- 0.2
RecombFit <- 0

qp <- 0.95
ExcitPSIIPhotons = FlashletEx * Photons_umol * sigmaPSII * FlashTrain * Flashlet_s

ExcitPSIIPhotons

tau_s = 1e-3

PSIIreopen = PSIIo - (PSIIo * exp(-1/tau_s  * FlashTrain * (Flashlet_s + Dark_s)))

PSIIreopen
```

```{r import clean data}

FitFilesSol <- list.files(path = DataIn, pattern = FileID, full.names = TRUE)

read.RDS <- function(flnm){readRDS(flnm) |>
    mutate(filename = flnm)
}

#test for duplicate file names
unique(duplicated(FitFilesSol))

LOW_SolFits <- FitFilesSol |>
  purrr::map_df(~read.RDS(flnm = .))


```

```{r dummy data}
DummyData <- tibble(FlashTrain = c(1:12), FM = c(63, 56, 56, 60, 59, 57, 58, 59, 58, 57, 58, 58))

DummyData |>
  ggplot() +
  geom_line(aes(x = FlashTrain, y = FM)) +
  theme_bw()
```


Measure fraction of PSII closed after a flashtrain; that gives fraction of PSII that 'miss' advancing
Use Poisson distribution to estimate probability of double turnover during tau
Check on simulataneous rates arithmetic

```{r simulation}
Simulate <- tibble(Flash = c(0:59),
                   SState = rep(c(1:4),times = 15),
                   PSIIadvance = PSIIo * qp^Flash) |>
  mutate(YSPSII = case_when(SState == 1 ~ 1,
                           SState == 2 ~ 0.9,
                           SState == 3 ~ 0.9,
                           SState == 4 ~ 1)) |>
  mutate(meanYSPSII = mean(YSPSII)) |>
  mutate(FM = ((PSIIadvance * YSPSII) + ((PSIIo - PSIIadvance) * meanYSPSII))/PSIIo) |>
  mutate(YSPSIIupper = meanYSPSII + (meanYSPSII * SNL),
         YSPSIIlower = meanYSPSII - (meanYSPSII * SNL)) |>
  mutate(SignifFlash = if_else(FM <= YSPSIIupper & FM >= YSPSIIlower, 0, 1))

Simulate <- Simulate |>
   mutate(FlashThreshold =  as.numeric(filter(Simulate, SignifFlash == 1) |>
  slice_tail(n = 1) |>
   select(Flash))
   )

                  #PSIIreopen = PSIIclose - (PSIIclose * exp(-1/tau_s  * FlashTrain * (Flashlet_s + Dark_s))) # have measured qP C from Solisense
                   #PSIInet = PSIIclose - PSIIreopen) |>


```


```{r simulate plot}
Simulate |>
  ggplot() +
  geom_point(aes(x = Flash, y = PSIIadvance/PSIIo)) +
  geom_point(aes(x = Flash, y = FM, colour = as.factor(SignifFlash))) +
  geom_line(aes(x = Flash, y = YSPSIIupper), linetype = "dashed", colour = "green") +
  geom_line(aes(x = Flash, y = YSPSIIlower), linetype = "dashed", colour = "green") +
  geom_vline(xintercept = Simulate$FlashThreshold[1], linetype = "dashed", colour = "darkgreen") +
  geom_text(aes(x = FlashThreshold[1] + 1, y = 0.6, label = paste("Significance Threshold", SNL, FlashThreshold[1], sep = " ")), colour = "darkgreen") +
  
  
  theme_bw()
```


```{r simulate with recombination and noise}
Simulate <- Simulate |>
  #mutate(PSIIadvancerecomb = PSIIadvance - (PSIIadvance * Recomb), .after = PSIIreopen) |>
  mutate(PSIIadvancerecomb = PSIIadvance - (PSIIadvance * Recomb), .after = PSIIadvance) |>
  mutate(PSIIadvancerecombnoise = PSIIadvancerecomb * (1 + rnorm(n=10, sd = SNL))) |>
  mutate(FMrecombnoise = ((PSIIadvancerecombnoise * YSPSII) + ((PSIIo - PSIIadvancerecombnoise) * meanYSPSII))/PSIIo) |>
  mutate(SignifFlashrecombnoise = if_else(FMrecombnoise <= YSPSIIupper & FMrecombnoise >= YSPSIIlower, 0, 1)) |>
  mutate(FlashrecombnoiseThreshold =  as.numeric(filter(Simulate, SignifFlashrecombnoise == 1) |>
  slice_tail(n = 1) |>
   select(Flash))
  )

#Issue with PSIIo does not take into account re-closure of PSIIo upon subsequent flashes, but they will be out of sync

  Simulate |> 
  ggplot() +
    #geom_point(aes(x = Flash, y = PSIInetnoise/PSIIo)) + 
    geom_point(aes(x = Flash, y = PSIIadvancerecombnoise/PSIIo), colour = "red") +
    #geom_point(aes(x = Flash, y = FMnoise, colour = as.factor(SignifFlashnoise))) +
    geom_point(aes(x = Flash, y = FMrecombnoise, colour = as.factor(SignifFlashrecombnoise))) +
    geom_line(aes(x = Flash, y = YSPSIIupper), linetype = "dashed", colour = "green") +
    geom_line(aes(x = Flash, y = YSPSIIlower), linetype = "dashed", colour = "green") +
    geom_vline(xintercept = Simulate$FlashrecombnoiseThreshold[1], linetype = "dashed", colour = "red") +
    geom_text(aes(x = FlashrecombnoiseThreshold[1] + 1, y = 0.5, label = paste("Signif Thresh:", FlashrecombnoiseThreshold[1], "SNL:", SNL, "qP:", qp,  "Recomb:", Recomb,  sep = " "))) +
  geom_vline(xintercept = Simulate$FlashThreshold[1], linetype = "dashed", colour = "darkgreen") +
  geom_text(aes(x = FlashThreshold[1] + 1, y = 0.6,  label = paste("Signif Thresh:", FlashThreshold[1], "SNL:", SNL, "qP:", qp, sep = " ")), colour = "darkgreen") +
  theme_bw()
```

# Set up optimization function to chose level of Recombination that matches data, with inputs of 'known' qP for expected SState cycling in the absence of Recombination
https://rstudio-pubs-static.s3.amazonaws.com/140054_deff0e911755406a87a2492d46f86d90.html

```{r find recomb}
#RecombFit <- 0.5

Simulate <- Simulate |>
   mutate(FMfit = (((PSIIadvance - (PSIIadvance * RecombFit)) * (1 + rnorm(n=10, sd = SNL)) * YSPSII) + ((PSIIo - (PSIIadvance - (PSIIadvance * RecombFit)) * (1 + rnorm(n=10, sd = SNL))) * meanYSPSII))/PSIIo) |>
    mutate(FMgap2 = (FMfit - FMrecombnoise)^2,
         FMsum2 = sum(FMgap2))


 Simulate |> 
  ggplot() +
   geom_point(aes(x = Flash, y = FMrecombnoise, colour = as.factor(SignifFlashrecombnoise))) +
   geom_line(aes(x = Flash, y = YSPSIIupper), linetype = "dashed", colour = "green") +
   geom_line(aes(x = Flash, y = YSPSIIlower), linetype = "dashed", colour = "green") +
   geom_point(aes(x = Flash, y = FMfit)) +
   geom_point(aes(x = Flash, y = FM)) +
  theme_bw()
 
```

fmgap <- function(FM, FMrecombnoise) {
        100 - 0.5 * price #a linear function
}
revenues <- function(price) {
        price * sales(price) #a non-linear function
}
par(mfrow = c(1, 2))
curve(sales, from = 0, to = 300, xname = 'Price', ylab = 'Sales', main = 'Sales')
curve(revenues, from = 0, to = 300, xname = 'Price', ylab = 'Revenues', main = 'Revenues')

par(mfrow = c(1, 1))
optimize(revenues, interval = c(50, 150), maximum = TRUE)