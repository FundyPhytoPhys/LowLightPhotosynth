---
title: "Wavelet transformation"
author:
- Natasha Ryan
- Maximilian Berthold
date: "`r format(Sys.Date())`"
output:
  html_document:
    df_print: paged
    code_folding: hide
    keep_md: yes
    fig_caption: yes
    toc: TRUE
    toc_float: TRUE   
csl: plos-one.csl
editor_options: 
  chunk_output_type: inline
---

# Introduction
This RMD computes a wave transformation and extracts the duration of fluorescence oscillations for the cleaned data generated from the OttawaImport, TakuvikImport, and SackvilleImport RMDs. 

```{r load libraries}
library(tidyverse)
library(doBy)
library(WaveletComp)
```


# Set Project Variables
```{r set project variables}
Project <- "LOW"
DataIn <- file.path("..","Data", "CleanData")
CalibData <- file.path("..","Data", "CalibData")
DataOut <- file.path("..","Data", "ProcessedData")
FileID <- "SolFitsTrim"
timeseries <- "FvFmrunnorm" #specifies variable for wavelet transformation
siglvl_reconstruct <- 0.05 #specifies significance level for reconstructed wave 
Fc <- "Fragilariopsis_cylindrus"
Ci <- "Chlamydomonas_ICEMDV"
Cm <- "Chlamydomonas_malina"
Cp <- "Chlamydomonas_priscuii"
Cr <- "Chlamydomonas_reinhardtii"
Cv <- "Chlorella_vulgaris"
Tp <- "Thalassiosira_pseudonana"
```


```{r create functions}
read.RDS <- function(flnm){readRDS(flnm) %>%
    mutate(filename = flnm)
}

#function for wavelet transformation 
wavelet <- function(data){wavelet_result <- WaveletComp::analyze.wavelet(data, timeseries,
                                     #method = "white.noise",
                                     #loess.span = 0.75, 
                                     #dt = 1, 
                                     #make.pval = TRUE, 
                                     n.sim = 500,
                                     verbose = FALSE)
return(wavelet_result)
}


#function for wavelet reconstruction, applies reconstruct() function from WaveletComp to all wavelets in a list
reconstructwave <- function(wavelet_list) {
  reconstructed_list <- lapply(wavelet_list, function(wave) {
    WaveletComp::reconstruct(wave, siglvl = siglvl_reconstruct, 
                             #plot.waves = TRUE, 
                             plot.rec = FALSE,
                             verbose = FALSE)
 })
  return(reconstructed_list) 
}


#function to extract the number of oscillating flashes from the reconstruction 
damping <- function(reconstructed) {
  result_list <- lapply(reconstructed, function(condition) {
    return(condition$series)
  }) #extract reconstructed wave data from 'reconstruct' objects 
  result_df <- data.frame(condition = character(0), damping.index = integer(0), stringsAsFactors = FALSE)
  
  for (condition in names(result_list)) {
    extract <- result_list[[condition]] 
    
    extract$difference <- c(NA, diff(extract$`FvFmrunnorm.r`)) #calculate difference in reconstructed FvFm values between successive rows 
    
    cycling.flashes <- which(extract$difference != 0) #extract row index where FvFm is oscillating
    
    damping.index <- max(cycling.flashes) #extract the highest row index (last row before FvFm damps)
    
    result_df <- rbind(result_df, data.frame(condition = condition, damping.index = damping.index))
  }
  return(result_df)
}
```


# Takuvik

### Fc
```{r import Fc data}
SolFitsFc <- list.files(path = DataIn, pattern = paste(Fc,FileID, sep = "_"), full.names = TRUE) %>%
  map_df(~read.RDS(flnm = .)) 

Fcdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsFc, FUN=c(mean), keep.names = TRUE) %>%
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Fc}
Fc_wavelets <- lapply(Fcdata, wavelet)
```

```{r reconstruct waves Fc}
Fc_reconstructed <- reconstructwave(Fc_wavelets)
```

```{r damping index Fc}
Fc_damping <- damping(Fc_reconstructed) %>% 
  mutate(Species = Fc)
```


# Ottawa 

### Ci
```{r import Ci data }
SolFitsCi <- list.files(path = DataIn, pattern = paste(Ci,FileID, sep = "_"), full.names = TRUE) %>%
  map_df(~read.RDS(flnm = .))

Cidata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsCi, FUN=c(mean), keep.names = TRUE) %>%
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Ci}
Ci_wavelets <- lapply(Cidata, wavelet)
```

```{r reconstruct waves Ci}
Ci_reconstructed <- reconstructwave(Ci_wavelets)
```

```{r damping index Ci}
Ci_damping <- damping(Ci_reconstructed) %>% 
  mutate(Species = Ci)
```


### Cm 
```{r import Cm data}
SolFitsCm <- list.files(path = DataIn, pattern = paste(Cm, FileID, sep = "_"), full.names = TRUE) %>% 
  map_df(~read.RDS(flnm = .)) 

Cmdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsCm, FUN=c(mean), keep.names = TRUE) %>% 
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Cm}
Cm_wavelets <- lapply(Cmdata, wavelet)
```

```{r reconstruct wave Cm}
Cm_reconstructed <- reconstructwave(Cm_wavelets)
```

```{r damping index Cm}
Cm_damping <- damping(Cm_reconstructed) %>%
  mutate(Species = Cm)
```


### Cp
```{r import Cp data}
SolFitsCp <- list.files(path = DataIn, pattern = paste(Cp,FileID, sep = "_"), full.names = TRUE) %>%
  map_df(~read.RDS(flnm = .))

Cpdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsCp, FUN=c(mean), keep.names = TRUE) %>%
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Cp}
Cp_wavelets <- lapply(Cpdata, wavelet)
```

```{r reconstruct wave Cp}
Cp_reconstructed <- reconstructwave(Cp_wavelets)
```

```{r damping index Cp}
Cp_damping <- damping(Cp_reconstructed) %>%
  mutate(Species = Cp)
```


### Cr
```{r import Cr data}
SolFitsCr <- list.files(path = DataIn, pattern = paste(Cr,FileID, sep = "_"), full.names = TRUE) %>% 
  map_df(~read.RDS(flnm = .)) 

Crdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsCr, FUN=c(mean), keep.names = TRUE) %>% 
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Cr}
Cr_wavelets <- lapply(Crdata, wavelet)
```

```{r reconstruct wave Cr}
Cr_reconstructed <- reconstructwave(Cr_wavelets)
```

```{r damping index Cr}
Cr_damping <- damping(Cr_reconstructed) %>%
  mutate(Species = Cr)
```


# Sackville 

### Cv
```{r import clean  data}
SolFitsCv <- list.files(path = DataIn, pattern = paste(Cv, FileID, sep = "_"), full.names = TRUE) %>%
  map_df(~read.RDS(flnm = .))

Cvdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsCv, FUN=c(mean), keep.names = TRUE) %>% 
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Cv}
Cv_wavelets <- lapply(Cvdata, wavelet)
```

```{r reconstruct wave Cv}
Cv_reconstructed <- reconstructwave(Cv_wavelets)
```

```{r damping index Cv}
Cv_damping <- damping(Cv_reconstructed) %>%
  mutate(Species = Cv)
```


### Tp
```{r import Tp data}
SolFitsTp <- list.files(path = DataIn, pattern = paste(Tp ,FileID, sep = "_"), full.names = TRUE)  %>%
  map_df(~read.RDS(flnm = .)) 

Tpdata <- summaryBy(FvFmrunnorm ~ Temp_C + PulseSpace_s + Flashnumber, data=SolFitsTp, FUN=c(mean), keep.names = TRUE) %>% 
  mutate(Condition = paste0(Temp_C,"C","_",PulseSpace_s,"s")) %>%
  split_by("Condition", drop=FALSE)
```

```{r wavelet transformation Tp}
Tp_wavelets <- lapply(Tpdata, wavelet)
```

```{r reconstruct wave Tp}
Tp_reconstructed <- reconstructwave(Tp_wavelets)
```

```{r damping index Cv}
Tp_damping <- damping(Tp_reconstructed) %>%
  mutate(Species = Tp)
```


# Merging Results 

```{r merge}
sstate_damping <- rbind(Fc_damping, Ci_damping, Cm_damping, Cp_damping, Cr_damping, Cv_damping, Tp_damping) %>%
  relocate(Species, .before = condition) %>%
  separate(condition, into=c("Temp_C", "PulseSpace_s"), sep = "_") %>%
  mutate(PulseSpace_s = str_remove(PulseSpace_s, "s")) %>%
  mutate(Temp_C = str_remove(Temp_C, "C")) %>%
  rename(DampingIndex = damping.index) 
```

```{r saving as RDS}
#save as RDS to be able to work on figures without running wavelet transformations
saveRDS(sstate_damping, file.path(DataOut, paste(Project, "SState_Damping.RDS", sep = "_"), fsep = .Platform$file.sep))
```


# Figures 
```{r import RDS}
#sstate_damping <- readRDS("../Data/ProcessedData/LOW_SState_Damping.Rds")
```


```{r figure setup}
sstate_damping$PulseSpace_s <- factor(sstate_damping$PulseSpace_s, levels = c("16","8","4","2","1"))
sstate_damping$Temp_C <- factor(sstate_damping$Temp_C, levels = c("0","2","4","6","8","10","12","14","16","18","20","22","24"))

species.labs <- c("Chlamydomonas ICEMDV", "Chlamydomonas malina", "Chlamydomonas priscuii", "Chlamydomonas reinhardtii", "Chlorella vulgaris", "Fragilariopsis cylindrus", "Thalassiosira pseudonana")
names(species.labs) <- c("Chlamydomonas_ICEMDV", "Chlamydomonas_malina", "Chlamydomonas_priscuii", "Chlamydomonas_reinhardtii", "Chlorella_vulgaris", "Fragilariopsis_cylindrus", "Thalassiosira_pseudonana")
```
 

```{r heat map}
sstate_damping %>% 
  #filter(PulseSpace_s %in% c("8","4","2","1")) %>%
  ggplot() + 
  geom_tile(aes(x = Temp_C, y = PulseSpace_s, fill = DampingIndex)) +  
  viridis::scale_fill_viridis(option="inferno") + 
  facet_wrap(vars(Species), scales = "free", labeller = labeller(Species=species.labs)) +  
  theme_linedraw() +
  theme(strip.text = element_text(face = "italic"))
```

```{r line plot}
sstate_damping %>% 
  ggplot() + 
  geom_point(aes(x = PulseSpace_s, y = DampingIndex, colour = Temp_C)) +
  geom_line(aes(x = as.numeric(PulseSpace_s), y = DampingIndex, colour = Temp_C)) +
  viridis::scale_color_viridis(option="inferno", discrete=TRUE) + 
  facet_wrap(vars(Species), scales = "free", labeller = labeller(Species=species.labs)) +  
  theme_linedraw() +
  theme(strip.text = element_text(face = "italic"))
```


# Previous Methods

Method when breaking up the data by run and analyzing each with it's own wavelet
```{r WVT 16s 10C}
# Data_16S_10C <- list(
#   (SolFits %>% filter(Temp_C == "10", PulseSpace_s == 16) %>% slice(1:32)), 
#   (SolFits %>% filter(Temp_C == "10", PulseSpace_s == 16) %>% slice(33:64)), 
#   (SolFits %>% filter(Temp_C == "10", PulseSpace_s == 16) %>% slice(65:96)), 
#   (SolFits %>% filter(Temp_C == "10", PulseSpace_s == 16) %>% slice(97:127)))
#   
# wavelet_16s_10C <- lapply(Data_16S_10C, wavelet)
# 
# reconstructwave(wavelet_16s_10C)
```


Original method by Max: generates the wavelet power and heat map graphs
```{r}
# LOW_SolFits_1s_10C <- LOW_SolFits %>%
#   filter(Temp_C == "10",
#          PulseSpace_s == 1)
# 
# WVT_10C_1s <- analyze.wavelet(LOW_SolFits_1s_10C, "FvFm",
#                         method = "white.noise",
#                         loess.span = 0, 
#                         dt = 1, dj = 1/500,
#                         lowerPeriod = 2, upperPeriod = 36,
#                         make.pval =TRUE, n.sim = 100)
# 
# MP_DeSpBl <- max(WVT_10C_1s$Power)
# 
# #sequential lines act like they are piped; need to run as a unit
# #png(filename = "../Output/AvPw_WT_LOW_Fragilariopsis_SolFits_1s_10C.png")
# wt.avg(WVT_10C_1s, show.siglvl = TRUE, siglvl =  0.05,maximum.level = 1,   #set level to mark significance
# periodlab = "Periodicity",
# main = "Fragilariopsis 10C, Pulse space 1 sec")
# #dev.off()
# 
# #y axis is log2 scale not linear
# #png(filename = "../Output/WT_LOW_Fragilariopsis_SolFits_1s_10C.png")
# wt.image(WVT_10C_1s, periodlab = "Periodicity",
# legend.params = list(lab = "wavelet power levels"),
# label.time.axis = TRUE,
# plot.legend = TRUE, plot.contour = TRUE,
# maximum.level = 1.001 * MP_DeSpBl,
# show.date = TRUE, date.format = "%F %S",
# main = "Fragilariopsis 10C, Pulse space 1 sec")
# #dev.off()

```

Plots: 
```{r Plot of wavelet power}
# wt.avg(relevant_wave, show.siglvl = TRUE, siglvl =  0.05,maximum.level = 1,   
# periodlab = "Periodicity",
# main = "Title") 
# 
# MP_DeSpBl <- max(relevant_wave$Power)
# wt.image(relevant_wave, periodlab = "Periodicity",
# color.key= "i", 
# legend.params = list(lab = "wavelet power levels"),
# label.time.axis = TRUE,
# plot.legend = TRUE, plot.contour = TRUE,
# maximum.level = 1.001 * MP_DeSpBl,
# #show.date = TRUE, date.format = "%F %S",
# main = "Title")
```
